---
title: "Hit Songs Through the Decades"
subtitle: "A Machine Learning Approach to Predicting Release Periods and Analyzing Trends in Popular Music"

author:

 - Andrea Lovato
 - Elwin Freudiger
 - Maya Wahart

institute: University of Lausanne
date: "May 17, 2025"
title-block-banner: "#0095C8" # chosen for the university of lausanne
toc: true
toc-location: right
format: 
  html:
    number-sections: true
    html-math-method: katex
    self-contained: true
    code-overflow: wrap
    code-fold: true
    code-tools: true
    theme: 
      light: "flatly"
      dark: "darkly"
    include-in-header: 
      text: |
        <style type="text/css">
          .quarto-title-banner a {
            color: #000000;
          }
        </style>

editor: visual

abstract: |
---

```{r}
#| echo: false
#| message: false

library(knitr)
library(tidyverse)
library(kableExtra)
library(broom)
library(reshape2)
library(magrittr)
library(corrplot)
library(plotly)
library(ggcorrplot)
library(factoextra)
library(FactoMineR)
library(dplyr)
library(ggplot2)
library(corrplot)
library(randomForest)
library(rpart)
library(rpart.plot)
library(lubridate)
library(caret)
library(rsample)
```

```{r}
#| echo: false
library(readr)

spotify <- read_csv("top_10000_1950-now.csv")
```

# Introduction

## Project Goals

The primary objective of this project is to apply machine learning techniques to a dataset of 10,000 top-charting songs from the ARIA and Billboard rankings, spanning from the 1950s to 2024. Using audio and metadata features provided by Spotify, the project aims to explore the evolution of musical trends and understand the key characteristics that define popular music across different decades.

From a machine learning perspective, the project focuses on both supervised and unsupervised learning tasks. This includes building predictive models to estimate a song’s release period based on its features, and using clustering algorithms to uncover latent patterns in the data. The goal is not only to analyze historical music trends but also to assess the feasibility and accuracy of predictive modeling in the context of music analytics.

## Adjustments or Refinements

????

# Data

## Sources

The dataset employed in this study, titled *“Top 10,000 Spotify Songs – ARIA and Billboard Charts”*, was obtained from Kaggle, a widely used platform for sharing datasets and data science resources. It comprises a curated collection of 10,000 tracks that have achieved significant popularity, based on historical rankings from both the ARIA (Australian Recording Industry Association) and Billboard charts. This dual-source approach ensures a broad and balanced representation of commercially successful music across English-speaking markets.

The dataset spans a temporal range from the 1950s to 2024, capturing the dynamic evolution of popular music over more than seven decades. It includes metadata and audio-based features extracted via the Spotify API, such as tempo, energy, danceability, valence, and instrumentalness, which allow for detailed computational analysis.

In addition to representing a variety of genres, artists, and time periods, the dataset reflects shifting cultural and musical preferences. As such, it provides a robust foundation for both exploratory data analysis and machine learning applications, particularly those aimed at uncovering temporal trends, predicting historical context (e.g., release period), and identifying latent patterns in music characteristics.

## Description

```{r}
dim(spotify)
```

The dataset comprises 10,000 entries and 35 variables, encompassing information related to song popularity, artist identity, release date, and various musical attributes.

| Variable | Description | Category | Example |
|------------------|------------------|------------------|------------------|
| track_uri | Unique identifier for the track | character | spotify:track:123... |
| track_name | Name of the track | character | Bohemian Rhapsody |
| artist_uris | URIs of artists performing the track | character | spotify:artist:abc... |
| artist_names | Name(s) of the performing artist(s) | character | Queen |
| album_uri | Unique identifier for the album | character | spotify:album:def... |
| album_name | Title of the album | character | A Night at the Opera |
| album_artist_uris | URIs of the album's main artist(s) | character | spotify:artist:abc... |
| album_artist_names | Name(s) of the album's main artist(s) | character | Queen |
| release_date | Date the album was released | date | 1975-11-21 |
| album_image_url | Link to album cover image | character | https://i.scdn.co/image/... |
| disc_number | Disc number of the track in multi-disc sets | numeric | 1 |
| track_number | Track's position on the disc | numeric | 11 |
| duration_ms | Length of the track in milliseconds | numeric | 354000 |
| preview_url | URL to 30-second preview of the track | character | https://p.scdn.co/mp3-preview/... |
| is_explicit | Indicates if track has explicit content | logical | TRUE |
| popularity | Spotify popularity score (0-100) | integer | 85 |
| isrc | International Standard Recording Code | character | GBUM71029604 |
| added_by | User who added the track to playlist | character | user_id_123 |
| added_at | Timestamp when track was added | datetime | 2022-07-15T12:00:00Z |
| artist_genres | Genres associated with the artist(s) | character | rock, classic rock |
| danceability | How suitable a track is for dancing | numeric | 0.6 |
| energy | Intensity and activity level of the track | numeric | 0.85 |
| key | Musical key of the track (0=C, 1=C♯, ...) | integer | 5 |
| loudness | Overall loudness in decibels | numeric | -5.3 |
| mode | Modality: major (1) or minor (0) | integer | 1 |
| speechiness | Presence of spoken words in the track | numeric | 0.05 |
| acousticness | Confidence that track is acoustic | numeric | 0.02 |
| instrumentalness | Likelihood that track is instrumental | numeric | 0.001 |
| liveness | Likelihood of live audience presence | numeric | 0.09 |
| valence | Musical positiveness conveyed | numeric | 0.7 |
| tempo | Beats per minute (BPM) | numeric | 120.5 |
| time_signature | Estimated time signature | integer | 4 |
| album_genres | Genres associated with the album | character | rock, progressive rock |
| label | Record label | character | EMI |
| copyrights | Copyright info for the album or track | character | ℗ 1975 Queen Productions Ltd. |

```{r}
#| echo: false

# Preview the dataset
knitr::kable(head(spotify), 
             format = "markdown", 
             align = 'c', 
             table.attr = 'class="table table-bordered"',
             row.names = FALSE) %>%
  kable_styling(font_size = 10, full_width = FALSE, position = "center")

```

## Wrangling / Cleaning

In preparation for analysis, the original dataset was cleaned and standardized by renaming variables to follow consistent, machine-readable naming conventions. Redundant or non-essential columns—such as URIs, preview links, and metadata unrelated to audio features—were subsequently removed. The resulting dataset *spotify_vr* retains only the relevant musical, temporal, and popularity-related attributes needed for the subsequent exploratory and predictive modeling tasks.

```{r}
spotify <- spotify |>
  rename(
    track_uri            = `Track URI`,
    track_name           = `Track Name`,
    artist_uris          = `Artist URI(s)`,
    artist_names         = `Artist Name(s)`,
    album_uri            = `Album URI`,
    album_name           = `Album Name`,
    album_artist_uris    = `Album Artist URI(s)`,
    album_artist_names   = `Album Artist Name(s)`,
    release_date         = `Album Release Date`,
    album_image_url      = `Album Image URL`,
    disc_number          = `Disc Number`,
    track_number         = `Track Number`,
    duration_ms          = `Track Duration (ms)`,
    preview_url          = `Track Preview URL`,
    is_explicit          = `Explicit`,
    popularity           = `Popularity`,
    isrc                 = `ISRC`,
    added_by             = `Added By`,
    added_at             = `Added At`,
    artist_genres        = `Artist Genres`,
    danceability         = `Danceability`,
    energy               = `Energy`,
    key                  = `Key`,
    loudness             = `Loudness`,
    mode                 = `Mode`,
    speechiness          = `Speechiness`,
    acousticness         = `Acousticness`,
    instrumentalness     = `Instrumentalness`,
    liveness             = `Liveness`,
    valence              = `Valence`,
    tempo                = `Tempo`,
    time_signature       = `Time Signature`,
    album_genres         = `Album Genres`,
    label                = `Label`,
    copyrights           = `Copyrights`
  )
```

```{r}
spotify_vr <- spotify |>
  select(-artist_uris, -album_uri,-album_artist_uris,-album_artist_names, -disc_number,-preview_url, -isrc, -added_by, -added_at, -album_genres, -copyrights,-key)

ncol(spotify_vr)
```

The resulting dataset consists of 23 columns, containing only the variables relevant for the subsequent analysis after the removal of redundant and non-informative features.

We only keep the ID from the Spotify track URL by extracting the final component of the *track_uri* string.

```{r}
library(dplyr)
library(stringr)

spotify_vr <- spotify_vr |>
  mutate(track_uri = str_extract(track_uri, "[^:]+$"))
```

```{r}
#| echo: false

# Preview the dataset
knitr::kable(head(spotify_vr), 
             format = "markdown", 
             align = 'c', 
             table.attr = 'class="table table-bordered"',
             row.names = FALSE) %>%
  kable_styling(font_size = 10, full_width = FALSE, position = "center")
```

## Spotting Mistakes and Missing Data

The procedure involves identifying and counting missing values in the dataset, detecting rows containing incomplete information, and removing those with missing or empty loudness values. Then, the release year is extracted from the release date and converted to a numeric format, producing a cleaned dataset ready for further analysis.

The dataset have a total of 625 missing values, including 551 for the 'artist_genres'.

We are going to drop the instance with missing feature about the music.

```{r}
# Count total missing values
sum(is.na(spotify_vr))  # This will return the total number of NAs

# Show missing values per column
colSums(is.na(spotify_vr))

#Rows with missing values
rows_with_missing <- spotify_vr |>
  filter(if_any(everything(), ~ is.na(.) | . == ""))

# View the rows
rows_with_missing

dataset_clean <- spotify_vr |>
  filter(!is.na(loudness) & loudness != "") %>% 
  mutate(release_year = as.numeric(substr(release_date, start = 1, stop = 4)))

colSums(is.na(dataset_clean))

```

The dataset contains a total of 625 missing values, of which 551 correspond to the *artist_genres* variable. Instances with missing values in variables related to musical characteristics are excluded from the analysis to ensure data quality and consistency.

## Listing Anomalies and Outliers

A subset of the dataset containing only numeric variables was selected, excluding *mode* and *time_signature*. The data was then transformed into long format to generate faceted boxplots, allowing for the visualization of the distribution and scale of each numeric variable individually.

```{r}
numeric_data <- dataset_clean %>% select(where(is.numeric)) |>
  select(-mode,-time_signature)

long_data <- pivot_longer(numeric_data, cols = everything(), names_to = "Variable", values_to = "Value")

# Faceted boxplots with individual y-axis scales
ggplot(long_data, aes(x = "", y = Value)) +
  geom_boxplot() +
  facet_wrap(~ Variable, scales = "free_y") +
  labs(title = "Boxplots for Numeric Variables (Individual Scales)", x = "", y = "") +
  theme_minimal()
```

### **Interpretation**

The faceted boxplots illustrate the distribution of key numeric features. Variables such as acousticness, energy, danceability, instrumentalness, liveness, valence, and speechiness are bounded between 0 and 1. Most exhibit distributions concentrated near zero, particularly instrumentalness and speechiness, which show long right tails and outliers close to 1, suggesting that while the average track lacks strong instrumental or spoken elements, some are highly characterized by them.

Duration (in milliseconds) is slightly right-skewed, with most tracks clustered around the median and a few outliers representing exceptionally long songs. Loudness is centered around negative values, consistent with its decibel scale relative to silence, and shows a compact distribution with occasional extreme lows, likely corresponding to quiet or highly dynamic tracks.

Popularity displays a broad distribution with outliers at both ends, indicating notable variability in audience reception. Tempo shows high variance and several extreme values, potentially due to anomalous entries or experimental compositions. Lastly, track number is typically low—reflecting songs positioned early in albums—though outliers suggest the presence of long compilations or inconsistent metadata.

## Summary statistics

Summary statistics are generated for all numeric variables in the cleaned dataset to provide an overview of central tendencies, dispersion, and the presence of potential outliers.

```{r}
# Summary statistics for key numeric features
dataset_clean %>%
  select_if(is.numeric) %>%
  summary() %>%
  kable() %>%
  kable_styling()

```

## Correlation Matrix

A correlation matrix is computed and visualized using a color-coded upper-triangle plot to identify linear relationships among the numeric variables in the cleaned dataset. This helps reveal patterns of association and potential multicollinearity between audio features.

```{r}
spotify_num <- dataset_clean %>%
  select_if(is.numeric) %>%
  na.omit()

corrplot(cor(spotify_num), method = "color", type = "upper", tl.cex = 0.7)

```

The correlation matrix reveals a moderate positive association between energy and loudness, suggesting that more energetic tracks tend to be louder. A notable negative correlation is observed between acousticness and energy, indicating that acoustic songs generally exhibit lower energy levels. Overall, the absence of strong correlations among most variables suggests low multicollinearity, supporting their joint inclusion in multivariate analyses.

# Exploratory Data Analysis

To gain a comprehensive understanding of the dataset and uncover patterns relevant to the modeling phase, an exploratory data analysis (EDA) is conducted. This phase involves the systematic examination of the dataset’s structure, distributions, and relationships among variables. We begin with summary statistics and visual inspections of key numeric features, followed by the analysis of correlations and potential multicollinearity. Subsequently, we investigate temporal trends, track characteristics, and the distribution of categorical variables such as explicit content and genre. This stepwise exploration helps identify data quality issues, potential outliers, and underlying trends that may influence or inform the subsequent application of machine learning techniques.

## Table description

????

For this data analysis, we will see different graphs....

## Summary statistics

The summary statistics table provides an overview of the central tendencies and dispersion of key variables in the dataset.

As we can see, regarding the release date, most songs have been released in more recent years. this may lead to unbalanced data. Ways to solve this unbalance will be discussed later in this paper. Regarding the track number in the song, the mean being at *4.9*, this tells us that most songs may part of an album or compilation. interestingly, the max of song number is *93* for a song named *Soul Revival* by *Johnny Diesel & The Injectors* part of a *Complete Eighties* compilation of 100 songs from the 80s.

The track duration is expressed in milliseconds, with a mean of *3 minutes and 44 seconds.* The longest song in record is a whopping 26 minutes. for *Tubular Bells - Pt. I* by *Mike Oldfield*. While this may not ring a bell (pun intended) for most readers, Amateurs of Horror may recognize this as the opening soundtrack for *The Exorcist (1973)* The audio preview below:

```{=html}
<audio controls>
  <source src="https://p.scdn.co/mp3-preview/2da01a5ad77fddb1bc2b0ed9e138a74eabe43333?cid=9950ac751e34487dbbe027c4fd7f8e99" type="audio/mpeg">
  Your browser does not support the audio element.
</audio>
```

The is_explicit variable is highly imbalanced, with approximately 95% of the songs labeled as non-explicit. The distribution of the popularity variable is not normally distributed, with a mean value of 33, indicating that most songs fall within a lower popularity range. Variables such as danceability, energy, key, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo, and time signature are audio features provided by Spotify that describe various musical characteristics of each track.

## Correlation matrix

A correlation matrix was computed and visualized to examine linear relationships between all numeric features in the dataset, highlighting potential associations and redundancies among audio variables.

```{r}
#start by selecting numeric columns
num_dataset <- dataset_clean %>% 
  select_if(is.numeric)

cor_matrix <- cor(num_dataset, use = "complete.obs")

ggcorrplot(
  cor_matrix,
  method    = "square",   
  lab       = TRUE,       
  lab_size  = 2,           
  tl.cex    = 10,        
  colors    = c("blue", "white", "red"), 
  outline.col = "gray80",
) +
  labs(
    title = "Correlation Matrix for Song features"
  ) +
  xlab(NULL)+ ylab(NULL)+
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust = 1))

```

## Variables analysis

### Release year

```{r}
#adding a histogram with songs by year
year_hist <- dataset_clean %>% 
  select(release_year) %>%
  filter(release_year>0) %>%
  ggplot(aes(x=release_year)) +
  geom_histogram(binwidth = 1, fill="blue", color="black") +
  theme_minimal() +
  labs(title = "Number of songs by release year", x="Year") 
year_hist
#year_hist %>% ggplotly()
```

Release year is the dependent variable in this analysis, and it is considered at the level of yearly granularity. The histogram shows a strong concentration of songs in more recent years, indicating a temporal imbalance that may affect the representativeness of earlier decades in the modeling phase.

### Track numbers

```{r}
track_dens <- dataset_clean %>% 
  filter(track_number!=0) %>% 
  ggplot(aes(x=track_number)) +
  geom_histogram(fill='blue', color='black') + 
  theme_minimal() +
  labs(title = "Track number density", y="Density", x="track number")
track_dens
  
```

The distribution of track numbers is highly skewed toward lower values, indicating that most songs appear early in albums, while higher values likely reflect compilations or large tracklists.

It may be interesting to assess whether Benford's Law applies to the distribution of track numbers.

```{r}
benford_distr <- data.frame(
  first_digit = 1:9,
  benford_pct = log10(1 + 1/(1:9)) * 100
)

benford <- dataset_clean %>% 
  filter(track_number!=0) %>% 
  mutate(first_digit = as.numeric(substr(as.character(track_number), 1, 1))) %>% 
  ggplot(aes(x = first_digit)) +
  geom_histogram(
    bins = 9,
    fill = "blue",
    color = "black",
    aes(y = after_stat(count / sum(count) * 100))
  ) +
  geom_line(
    data = benford_distr,
    aes(x = first_digit, y = benford_pct),
    color = "red",
    size = 1
  ) +
  scale_x_continuous(breaks = 1:9) +
  labs(
    title = "First Digit Distribution of Track Numbers vs Benford's Law",
    x = "First Digit",
    y = "Percentage"
  ) +
  theme_minimal()

benford

```

The distribution of the first digit in track numbers clearly deviates from the expected pattern described by Benford’s Law. This discrepancy is likely due to structural constraints in how music albums are organized. Most releases—such as singles, EPs, and standard albums—contain a relatively small and fixed number of tracks, typically ranging from 1 to 15. As a result, lower digits, particularly 1, dominate the distribution, not because of a naturally logarithmic phenomenon but due to intentional sequencing and formatting practices in album production. This illustrates how domain-specific conventions can override general statistical laws in structured datasets.

Lastly, the evolution of track numbers over time can be examined to assess whether album structure or track positioning has changed across decades, potentially reflecting shifts in music consumption formats or production practices.

```{r}
year_tracknum <- dataset_clean %>% 
  filter(release_year!=0,
         track_number!=0) %>% 
  ggplot(aes(x=release_year, y=track_number)) +
  geom_point(color = "blue", size = 2) +
  theme_minimal()  + 
  labs(title="Track number depending on the release year", y="Track Number", x="Release Year")
year_tracknum
```

The scatter plot shows no clear trend in the evolution of track numbers over time. While the majority of songs consistently appear in early album positions across decades, some outliers—particularly in more recent years—exceed typical album lengths, likely reflecting special editions, compilations, or digital releases with extended tracklists.

### Track Duration

The distribution of track duration, expressed in milliseconds, is examined to determine typical song lengths and to identify potential outliers, including exceptionally short or long tracks, which may affect subsequent analyses.

```{r}
duration_hist <- dataset_clean %>% 
  drop_na() %>% 
  mutate(duration_ms = duration_ms/1000) %>% 
  ggplot(aes(x=duration_ms)) +
  geom_histogram(bins=50, fill='blue', color='black') +
  theme_minimal() +
  labs(title ="Histogram of track durations", x="Track Duration (s)")
duration_hist
```

The histogram shows that the distribution of track durations is right-skewed, with most songs clustered around typical lengths and a limited number of extreme values representing unusually long tracks.

A line plot is used to visualize the evolution of median track duration over time. This allows identification of long-term trends, such as shifts in typical song lengths across decades, and highlights notable changes in production or consumption patterns.

```{r}
median_year <- dataset_clean %>% 
  drop_na() %>% 
  group_by(release_year) %>% 
  summarise(median_duration = median(duration_ms, na.rm = TRUE)) %>% 
  mutate(median_duration = median_duration/1000) %>% 
  ggplot(aes(y=median_duration, x=release_year))+
  geom_line(color='blue', size=1) + 
  theme_minimal()+
  labs(title="Evolution of median track duration by year", y="Median Duration (s)", x="Year")
median_year
```

The plot shows that median track duration increased steadily throughout the second half of the 20th century, reaching a peak in 1992 at approximately 260 seconds (4 minutes and 20 seconds). A gradual decline follows, particularly from the 2010s onward. This recent downward trend is likely influenced by changes in digital consumption patterns, where streaming platforms incentivize shorter songs due to skip behavior and payout structures based on play counts.

```{r}
duration_pop <- dataset_clean %>% 
  drop_na() %>%
  mutate(duration_ms = duration_ms/1000) %>% 
  ggplot(aes(y=duration_ms, x=popularity)) +
  geom_point(color="blue")
duration_pop
```

The scatter plot shows no strong correlation between duration and popularity, though popular songs tend to have standard lengths, while very long tracks are generally less popular.

### is_explicit

The proportion of explicit versus non-explicit songs is analyzed over time to observe how the prevalence of explicit content has evolved across different release years.

```{r}
explicit_year <- dataset_clean %>% 
  drop_na() %>% 
  group_by(release_year, is_explicit) %>%
  summarise(count = n(), .groups = "drop") %>% 
  ggplot(aes(x = release_year, y = count, fill = as.factor(is_explicit))) +
  geom_area(position = "fill", alpha=0.6) +
  scale_fill_manual(
    values = c("TRUE" = "red", "FALSE" = "lightgray"),
    name = "Explicit",
    labels = c("FALSE" = "Non-Explicit", "TRUE" = "Explicit")
  ) +
  labs(
    title = "Evolution of Explicit vs. Non-Explicit Songs",
    x = "Year",
    y = "Share",
    fill = "Explicit"
  ) +
  scale_y_continuous(labels = scales::percent) +
  theme_minimal()

explicit_year
```

The analysis reveals a clear upward trend in the share of explicit songs over time, with a marked increase beginning in the early 2000s. This suggests a shift in lyrical content or labeling practices in the streaming era, where explicit content has become more common in popular music releases.

A line plot is now used to visualize the annual count of explicit songs over time, offering a more detailed view of their increasing presence in recent decades.

```{r}
line_explicit <- dataset_clean %>% 
  drop_na() %>% 
  group_by(release_year) %>%
  summarise(
    total = n(),
    explicit_count = sum(is_explicit, na.rm = TRUE),
    explicit_share = explicit_count / total
  ) %>% 
  ggplot(aes(x = release_year, y = explicit_count)) +
  geom_line(color = "blue", size = 1) +
  labs(
    title = "Share of Explicit Songs Over Time",
    x = "Year",
    y = "Share of Explicit Songs"
  ) +
  theme_minimal()
line_explicit
```

The line plot confirms a rising trend in the number of explicit songs over time, particularly from the early 2000s onward. However, this pattern should be interpreted cautiously, as the explicit label is assigned by content uploaders and may not consistently reflect the presence of explicit material. In some cases, tracks with potentially explicit content are also released in censored versions to ensure broader distribution, such as radio play.

A boxplot is used to compare the distribution of song popularity between explicit and non-explicit tracks, allowing for the assessment of whether explicit content is associated with higher or lower popularity levels.

```{r}
explicit_boxplot <- dataset_clean %>% 
  drop_na() %>% 
  ggplot(aes(x = as.factor(is_explicit), y = popularity)) +
  geom_boxplot() +
  labs(
    title = "Popularity by Explicit Status",
    x = "Explicit",
    y = "Popularity"
  ) +
  theme_minimal()
explicit_boxplot
```

To further explore the relationship between explicit content and popularity, a scatter plot is used to visualize popularity scores over time, differentiated by explicit status. This approach helps assess whether the observed higher popularity of explicit songs is inherently tied to their content or instead influenced by temporal release patterns.

```{r}
explicit_popdate <- dataset_clean %>% 
  drop_na() %>% 
  ggplot(aes(x = release_year, y = popularity, color=as.factor(is_explicit))) +
  scale_color_manual(
    values = c("TRUE" = "red", "FALSE" = "blue"),
    name = "Explicit",
    labels = c("FALSE" = "Non-Explicit", "TRUE" = "Explicit")
  ) +
  geom_point() +
  labs(
    title = "Popularity by year with explicit status",
    x = "Release Year",
    y = "Popularity"
  ) +
  theme_minimal()
   #+ facet_wrap(vars(is_explicit))
explicit_popdate
```

The scatter plot reveals that explicit songs (in red) are predominantly concentrated in more recent years and often exhibit high popularity scores. This supports the hypothesis that the observed popularity advantage of explicit tracks may be confounded by release date, as newer songs are both more likely to be explicit and to benefit from recency effects in popularity metrics.

### Popularity

Popularity serves as a valuable proxy for a song’s commercial success and audience reach. While the exact algorithm used to calculate Spotify’s popularity score is not publicly disclosed, it is reasonable to assume that it reflects streaming frequency over a defined recent time window.

```{r}
# Summary statistics for key numeric features
dataset_clean %>%
  select(track_name, artist_names, popularity) %>% 
  arrange(desc(popularity)) %>%
  head() %>% 
  kable() %>%
  kable_styling()

```

It is important to note that the dataset was last updated in October 2024, meaning that the popularity scores reflect a specific point in time and may have since changed. However, this temporal limitation does not affect the validity of the present analysis, as the values still offer a reliable snapshot for exploring general trends and patterns in music popularity.

```{r}
avg_pop_date <- dataset_clean %>% 
  drop_na() %>% 
  group_by(release_year) %>% 
  summarise(avg_pop = mean(popularity, na.rm = TRUE)) %>%
  ggplot(aes(y=avg_pop, x=release_year))+
  geom_line(color='blue', size=1) + 
  theme_minimal()+
  labs(title="Evolution of mean popularity by year", y="Popularity", x="Year")
avg_pop_date
```

The chart shows peaks in popularity for early and recent songs. Older tracks remain culturally relevant, while the recent rise reflects the streaming era’s impact on visibility and access.

While the high popularity of recent songs is expected, the elevated scores for tracks from the 1960s are more surprising. A possible explanation is that many of these songs—such as those by The Beatles—have maintained lasting cultural relevance and continue to be featured in playlists and rankings, preserving their popularity across generations.

## Text mining

This section performs a basic text mining task by extracting and counting individual artist names from multi-artist tracks. The goal is to identify the top 30 most frequently appearing artists in the dataset.

```{r}
# Separate multiple artists
top_artists <- dataset_clean %>%
  filter(!is.na(artist_names)) %>%
  mutate(artist_names = str_split(artist_names, ",")) %>%
  unnest(artist_names) %>%
  mutate(artist_names = str_trim(artist_names)) %>%
  count(artist_names, sort = TRUE) %>%
  slice_head(n = 30)

# Plot
artist_bar <- ggplot(top_artists, aes(x = reorder(artist_names, n), y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Top 30 Artists by Song Count",
    x = "Artist",
    y = "Number of Songs"
  ) +
  theme_minimal()
artist_bar
```

This step identifies the top 10 artists with the highest average popularity scores, offering insights into which artists consistently produce well-received songs within the dataset.

```{r}
artist_pop <- dataset_clean %>%
  filter(!is.na(artist_names)) %>%
  mutate(artist_names = str_split(artist_names, ",")) %>%
  unnest(artist_names) %>%
  mutate(artist_names = str_trim(artist_names)) %>%
  group_by(artist_names) %>% 
  summarise(avg_pop = mean(popularity, na.rm = TRUE)) %>%
  arrange(desc(avg_pop)) %>%
  slice_head(n=10) %>% 
  kable() %>%
  kable_styling()
artist_pop
```

The following analysis ranks artists by their average track duration, highlighting those associated with longer musical compositions. Such patterns may reflect stylistic tendencies common in certain genres, including progressive rock, ambient, or experimental music.

```{r}
artist_len <- dataset_clean %>%
  filter(!is.na(artist_names)) %>%
  mutate(artist_names = str_split(artist_names, ",")) %>%
  unnest(artist_names) %>%
  mutate(artist_names = str_trim(artist_names)) %>%
  group_by(artist_names) %>% 
  summarise(avg_time = mean(duration_ms, na.rm = TRUE)) %>%
  arrange(desc(avg_time)) %>%
  slice_head(n=10) %>% 
  kable() %>%
  kable_styling()
artist_len
```

The following analysis focuses on the artists with the lowest average track durations, aiming to reveal trends related to brevity in musical production, which may be influenced by genre conventions or platform-driven listening behaviors.

```{r}
artist_len_inc <- dataset_clean %>%
  filter(!is.na(artist_names)) %>%
  mutate(artist_names = str_split(artist_names, ",")) %>%
  unnest(artist_names) %>%
  mutate(artist_names = str_trim(artist_names)) %>%
  group_by(artist_names) %>% 
  summarise(avg_time = mean(duration_ms, na.rm = TRUE)) %>%
  arrange(avg_time) %>%
  slice_head(n=10) %>% 
  kable() %>%
  kable_styling()
artist_len_inc
```

A similar type of analysis is now performed based on musical genre, in order to examine how average song characteristics vary across different stylistic categories.

```{r}
top_genres <- dataset_clean %>%
  mutate(artist_genres = replace_na(artist_genres, "No genre")) %>% 
  filter(!is.na(artist_genres)) %>%
  mutate(artist_genres = str_split(artist_genres, ",")) %>%
  unnest(artist_genres) %>%
  mutate(artist_genres = str_trim(artist_genres)) %>%
  count(artist_genres, sort = TRUE) %>%
  slice_head(n = 20)

# Plot
genre_bar <- ggplot(top_genres, aes(x = reorder(artist_genres, n), y = n)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  labs(
    title = "Top 20 Genres by Song Count",
    x = "Genre",
    y = "Number of Songs"
  ) +
  theme_minimal()
genre_bar
```

```{r}
genre_pop <- dataset_clean %>%
  mutate(artist_genres = replace_na(artist_genres, "No genre")) %>% 
  filter(!is.na(artist_genres)) %>%
  mutate(artist_genres = str_split(artist_genres, ",")) %>%
  unnest(artist_genres) %>%
  mutate(artist_genres = str_trim(artist_genres)) %>%
  group_by(artist_genres) %>% 
  summarise(avg_pop= mean(popularity, na.rm = TRUE)) %>%
  arrange(desc(avg_pop)) %>%
  slice_head(n=10) %>% 
  kable() %>%
  kable_styling()
  
genre_pop
```

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_ to be contued:

# Clustering

```{r}
clustering_data <- dataset_clean %>% 
  select(c(where(is.numeric), is_explicit)) %>% 
  select(-c(release_year)) %>% 
  drop_na() %>% 
  scale()
```

##K-means clustering

We'll start by fitting a k-means clustering. First, we need to determine the optimal number of clusters to use.

```{r}
fviz_nbclust(clustering_data,
             kmeans,
             method='wss',
             k.max = 100,
             verbose = FALSE)

```

As can be seen, the elbow seems to converge at around 5 clusters. We will therefore, take this as our number of clusters.

```{r}
song_km <- kmeans(clustering_data, centers=30)
```

To inspect these clusters we will start by having boxplots

```{r}
song_comp <- data.frame(clustering_data, 
                        Clust=factor(song_km$cluster),
                        Id=row.names(dataset_clean))
song_df <- melt(song_comp, id=c("Id", "Clust"))
head(song_df, 10)

ggplot(song_df, aes(y=value, group=Clust, fill=Clust)) +
  geom_boxplot() +
  facet_wrap(~variable)
```

As can be seen, no pattern seems to emerge from the k-means clustering. We may still attempt to have hierarchical clustering.

## Hierearchical clustering

```{r}
song_distances <- dist(clustering_data, method = "manhattan")
song_melt <- melt(as.matrix(song_distances)) 
head(song_melt)
```

```{r}
song_hc <- hclust(song_distances, method="complete")
```

```{r}
plot(song_hc, hang=-1)
rect.hclust(song_hc, k=13)
song_clust_hc <- cutree(song_hc, k=13)
song_clust_hc
```

Hierarchical clustering does not seem to accurately show differences between songs. Many reasons may lead to it being this way.

#PCA

```{r}
# 1. Prepare numeric data and keep release_year for color
pca_data <- dataset_clean %>%
  filter(release_year>0) %>% 
  drop_na() %>% 
  select(c(danceability, energy, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo)) %>%
  scale()

# 2. Run PCA on everything except release_year
pca_result <- prcomp(pca_data, scale. = TRUE)

# 3. Extract PCA scores and add release year for coloring
pca_scores <- as.data.frame(pca_result$x[, 1:2])
release_years <- dataset_clean %>%
  filter(release_year > 0) %>%
  drop_na() %>%
  pull(release_year)
pca_scores$release_year <- release_years

# 4. Extract loading for arrows
loadings <- as.data.frame(pca_result$rotation[, 1:2])
loadings$variable <- rownames(loadings)

# 5. Plot PCA with arrows and color by release year
ggplot(pca_scores, aes(x = PC1, y = PC2, color = release_year)) +
  geom_point(alpha = 0.6) +
  scale_color_viridis_c(option = "plasma") +
  geom_segment(data = loadings,
               aes(x = 0, y = 0, xend = PC1 * 5, yend = PC2 * 5),  # arrows, scaled
               arrow = arrow(length = unit(0.2, "cm")), color = "gray30") +
  geom_text(data = loadings,
            aes(x = PC1 * 5.3, y = PC2 * 5.3, label = variable),
            size = 3, color = "gray20") +
  labs(
    title = "PCA Biplot of Song Features",
    x = "PC1",
    y = "PC2",
    color = "Release Year"
  ) +
  theme_minimal()
```

```{r}
pca_data <- dataset_clean %>%
  filter(release_year>0) %>% 
  drop_na() %>% 
  select(c(danceability, energy, loudness, mode, speechiness, acousticness, instrumentalness, liveness, valence, tempo)) %>%
  scale()

songs_pca <- PCA(pca_data, ncp = 11, graph = FALSE)
songs_pca
```

```{r}
fviz_pca_var(songs_pca)
```

```{r}
fviz_contrib(songs_pca, choice = "var", axes = 1)
```

```{r}
fviz_pca_biplot(songs_pca)
```

```{r}
fviz_eig(songs_pca, addlabels = TRUE, ncp=11)
```

```{r}
library(gridExtra)
p1 <- fviz_pca_biplot(songs_pca, axes = 1:2) 
p2 <- fviz_pca_biplot(songs_pca, axes = 3:4) 
p3 <- fviz_pca_biplot(songs_pca, axes = 5:6) 
grid.arrange(p1, p2, p3, nrow = 2, ncol=2)
```

## Random Forest Balanced

# Supervised Learning

## Regression

## Random Forest with undersampling

```{r}
spotify_year <- dataset_clean |>
  mutate(
    year = as.numeric(substr(release_date, 1, 4)),
    decade = floor(year / 10) * 10
  )

spotify_dec  <- spotify_year |>
  count(decade, sort = TRUE)
```

```{r}
spotify_cleaned <- spotify_dec %>%
  filter(decade != 0)

spotify_grouped <- spotify_cleaned %>%
  mutate(
    decade_group = case_when(
      decade %in% c(1950, 1960) ~ "1950–1960",
      TRUE ~ as.character(decade)
    )
  )

spotify_grouped %>%
  count(decade_group, sort = TRUE)
```

```{r}
# Trouver la taille du plus petit groupe
min_n <- spotify_grouped |>
  count(decade_group) |>
  summarise(min_n = min(n)) |>
  pull(min_n)

# Échantillonnage équilibré
spotify_balanced <- spotify_grouped |>
  group_by(decade_group) |>
  slice_sample(n = min_n) |>
  ungroup()

spotify_balanced %>%
  count(decade_group, sort = TRUE)
```

```{r}
features <- c("danceability", "energy", "acousticness", "instrumentalness",
              "liveness", "loudness", "speechiness", "tempo", "valence", "duration_ms")

df <- spotify_balanced |>
  select(all_of(features), decade_group) |>
  rename(decade = decade_group) |>
  mutate(decade = as.factor(decade)) |>
  na.omit()

split <- initial_split(df, prop = 0.8, strata = decade)
train <- training(split)
test <- testing(split)

# Fit model
rf_model <- randomForest(decade ~ ., data = train)

# Predict
pred <- predict(rf_model, newdata = test)

# Accuracy
mean(pred == test$decade)
```

```{r}
# Predictions
pred <- predict(rf_model, newdata = test)

# Accuracy
accuracy <- mean(pred == test$decade)
print(accuracy)

# Confusion Matrix
confusionMatrix(pred, test$decade)
```

**Accuracy** (0.410): correctly predict the decade 41% of the time

**Kappa** (0.312): Fair agreement beyond chance, barely acceptable

**P-value** (\< 2e-16): Statistically better than random guessing

**No Info Rate** (14.3%): Baseline accuracy if you predicted the majority

## Random Forest on median year

```{r}
spotify_binary <- spotify_year |>
  mutate(
    after_median = if_else(year > median(year, na.rm = TRUE), "after", "before"),
    after_median = as.factor(after_median)
  )
```

```{r}
spotify_clean <- dataset_clean |>
  mutate(year = as.numeric(substr(release_date, 1, 4)))

# Calculate and display the median
median_year <- median(spotify_dec$year, na.rm = TRUE)
print(median_year)

spotify_binary <- spotify_clean |>
  mutate(
    after_median = if_else(year > median(year, na.rm = TRUE), "after", "before"),
    after_median = as.factor(after_median)
  )
```

The median song was release in 2007. We are going to perform a random forest on wether the song was release before or after this year.

```{r}
features <- c("danceability", "energy", "acousticness", "instrumentalness",
              "liveness", "loudness", "speechiness", "tempo", "valence", "duration_ms")

df <- spotify_binary |>
  select(all_of(features), after_median) |>
  na.omit()
```

```{r}
set.seed(123)
train_idx <- sample(seq_len(nrow(df)), size = 0.8 * nrow(df))
train <- df[train_idx, ]
test <- df[-train_idx, ]


rf_model <- randomForest(after_median ~ ., data = train, ntree = 500)
```

```{r}
# Predictions
pred <- predict(rf_model, newdata = test)

# Accuracy
accuracy <- mean(pred == test$after_median)
print(accuracy)

# Confusion Matrix
library(caret)
confusionMatrix(pred, test$after_median)
```

**Accuracy** (0.764): correctly classify \~76% of the songs.

**Kappa** (0.525): moderate agreement beyond chance, pretty good.

**Balanced** Acc. (0.762): handles class imbalance, very healthy.

**Sensitivity** (0.724): correctly detect 72.4% of songs after 2007.

**Specificity** (0.800): correctly detect 80% of songs before 2007.
